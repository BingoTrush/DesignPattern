# 面向对象

 - 函数式（结构化）
   - 顺序、判断、循环
 - 面向对象（数据结构化）
 - 对于计算机，结构化的才是最简单的
 - 编程应该： 简单 & 抽象

### 类
类，就是一个模板，可以通过它构造出很多对象。 类里面通常包含一些属性和方法。

### 对象
类的一个实例，一个实体，它拥有类的所有属性和方法，他与其他对象。


## 面向对象三要素

### 封装
 封装就是事物抽象为类，把对外接口暴露，将实现和内部数据隐藏，做到权限和保密。

从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的。 对象对它自己的行为负责。封装使得对象之间的耦合变松散，对象之间只通过暴露接口来通信。


### 继承
面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

通过继承创建的新类称为“子类”或“派生类”。
被继承的类称为“基类”、“父类”或“超类”。
继承的过程，就是从一般到特殊的过程。
要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。
在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。
 
继承概念的实现方式有三类：实现继承、接口继承和可视继承。
 - 实现继承是指使用基类的属性和方法而无需额外编码的能力；
 - 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；
 - 可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。


在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是“属于”关系。例如，Employee 是一个人，Manager 也是一个人，因此这两个类都可以继承 Person 类。但是 Leg 类却不能继承 Person 类，因为腿并不是一个人。

抽象类仅定义将由子类创建的一般属性和方法，创建抽象类时，请使用关键字 Interface 而不是 Class。

OO开发范式大致为：
```
划分对象  →  抽象类  →  将类组织成为层次化结构(继承和合成)  →  用类与实例进行设计和实现几个阶段。
```

### 多态

多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，同一接口不同实现。

 - 多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事 物”与 “可能改变的事物”分离开来。
 - 静态类型的面向对象语言通常被设计为可以向上转型:当给一个类变量赋值时，这个变量的类型既可以使用这个类本身，也可以使用这个类的超类。
 - 多态的最根本好处在于，你不必再向对象询问“你是什么类型”而后根据得到的答案调用对象的某个行为——你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。

多态例子： 在电影的拍摄现场，当导演喊出“action”时，主角开始背台词，照明师负责打灯 光，后面的群众演员假装中枪倒地，道具师往镜头里撒上雪花。在得到同一个消息时， 每个对象都知道自己应该做什么。如果不利用对象的多态性，而是用面向过程的方式来 编写这一段代码，那么相当于在电影开始拍摄之后，导演每次都要走到每个人的面前， 确认它们的职业分工(类型)，然后告诉他们要做什么。如果映射到程序中，那么程序 中将充斥着条件分支语句。

实现多态，有二种方式，覆盖，重载。

 - 覆盖，是指子类重新定义父类的虚函数的做法。
 - 重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。

其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。

如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。

那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚邦定）。结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关！引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚邦定，它就不是多态。”

那么，多态的作用是什么呢？我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。