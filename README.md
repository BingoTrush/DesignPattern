# 设计模式

### [面向对象](面向对象.md)


### [SOLID设计原则](设计原则.md)



### 23种设计模式
 - 创建型
   - 工厂模式
     - 工厂方法模式、抽象工厂模式、创建者模式
   - 单例模式
   - 原型模式
 - 组合型
   - 适配器模式
   - 装饰器模式
   - 代理模式
   - 外观模式
   - 桥接模式
   - 组合模式
   - 享元模式
 - 行为型
   - 策略模式
   - 模板方法模式
   - 观察者模式
   - 迭代器模式
   - 职责模式
   - 命令模式
   - 备忘录模式
   - 状态模式
   - 访问者模式
   - 中介者模式
   - 解释器模式



### ES6继承中的super
继承类中的构造函数必须调用 super（...），并且在使用 this 之前执行它。

但为什么哪？

在JavaScript中，继承了其他类的构造函数比较特殊。在继承类中，相应的构造函数被标记为特殊的内部属性 `[[ConstructorKind]]：“derived”`。

区别在于：

 - 当一个普通的构造函数运行时，它会创建一个空对象作为 this，然后继续运行。
 - 但是当派生的构造函数运行时，与上面说的不同，它指望父构造函数来完成这项工作。

所以如果我们正在构造我们自己的构造函数，那么我们必须调用 super，否则具有 this 的对象将不被创建，并报错。