# 设计模式

### [面向对象](面向对象.md)


### [环境搭建](环境搭建.md)


### [设计原则](设计原则.md)

 - `S`  单一职责原则
   - 一个程序只做好一件事
   - 如果功能过于复杂就拆分开，每隔部分保持独立
 - `O`  开放封闭原则
   - 对扩展开发，对修改封闭
   - 需求增加时，扩展新代码，而不是修改已有代码
   - 这是软件设计的终极目标
 - `L`  李氏置换原则
   - 子类能覆盖父类
   - 父类能出现的地方子类就能出现
 - `I`  接口独立原则
   - 保持接口的单一独立，尽量不要出现“胖接口”
   - 就像单一职责原则，但这里更关注接口
 - `D`  依赖导致原则
   - 面向接口编程，依赖于抽象而不依赖于具体
   - 使用方指关注接口而不是具体类的实现



### 23种设计模式
 - 创建型
   - 工厂模式
     - 工厂方法模式、抽象工厂模式、创建者模式
   - 单例模式
   - 原型模式
 - 组合型
   - 适配器模式
   - 装饰器模式
   - 代理模式
   - 外观模式
   - 桥接模式
   - 组合模式
   - 享元模式
 - 行为型
   - 策略模式
   - 模板方法模式
   - 观察者模式
   - 迭代器模式
   - 职责模式
   - 命令模式
   - 备忘录模式
   - 状态模式
   - 访问者模式
   - 中介者模式
   - 解释器模式



### ES6继承中的super
继承类中的构造函数必须调用 super（...），并且在使用 this 之前执行它。

但为什么哪？

在JavaScript中，继承了其他类的构造函数比较特殊。在继承类中，相应的构造函数被标记为特殊的内部属性 `[[ConstructorKind]]：“derived”`。

区别在于：

 - 当一个普通的构造函数运行时，它会创建一个空对象作为 this，然后继续运行。
 - 但是当派生的构造函数运行时，与上面说的不同，它指望父构造函数来完成这项工作。

所以如果我们正在构造我们自己的构造函数，那么我们必须调用 super，否则具有 this 的对象将不被创建，并报错。